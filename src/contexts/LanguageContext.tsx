import React, { createContext, useContext, useState, ReactNode } from 'react';

type Language = 'en' | 'zh';

export const translations = {
  en: {
    common: {
      name: 'Name',
      namespace: 'Namespace',
      metadata: 'Metadata',
      add: 'Add',
      cancel: 'Cancel',
      generate: 'Generate',
      delete: 'Delete',
      type: 'Type',
      key: 'Key',
      value: 'Value',
      port: 'Port',
      protocol: 'Protocol',
      selectOrType: 'Select or type...',
      requiredName: 'Please enter a name.',
      comment: 'Notes / Comments',
      commentPlaceholder: 'Add notes that will appear at the top of the YAML file...',
      commentHint: 'Comments will be displayed with # at the top of the generated YAML',
    },
    nav: {
      workloads: 'Workloads',
      network: 'Network',
      config: 'Config & Storage',
      deployment: 'Deployment',
      service: 'Service',
      ingress: 'Ingress',
      configmap: 'ConfigMap',
      secret: 'Secret',
      pvc: 'PVC',
      cronjob: 'CronJob',
      job: 'Job',
      daemonset: 'DaemonSet',
      statefulset: 'StatefulSet',
      hpa: 'HPA',
      apiKey: 'API Key',
      active: 'Active',
      missing: 'Missing',
      saved: 'Saved Configurations',
      noSaved: 'No saved configs yet.',
    },
    header: {
      config: 'Configuration',
      copy: 'Copy',
      copied: 'Copied',
      export: 'Export',
      preview: 'PREVIEW',
      save: 'Save',
      saveTitle: 'Save Current Configuration',
      configName: 'Configuration Name',
      saveBtn: 'Save to Local',
    },
    deploy: {
      specs: 'Specifications',
      replicas: 'Replicas',
      containerConfig: 'Container Configuration',
      containers: 'Containers',
      addContainer: 'Add Container',
      initContainers: 'Init Containers',
      addInitContainer: 'Add Init Container',
      containerName: 'Container Name',
      image: 'Image',
      pullPolicy: 'Image Pull Policy',
      resources: 'Resource Constraints',
      requests: 'Requests',
      limits: 'Limits',
      cpu: 'CPU',
      memory: 'Memory',
      envVars: 'Environment Variables',
      envFrom: 'Env From (Bulk Load)',
      envSourceType: 'Source Type',
      envValType: 'Value',
      envRefType: 'Ref',
      cmName: 'ConfigMap Name',
      cmKey: 'Key in CM',
      volumes: 'Volumes Definition',
      mounts: 'Container Mounts',
      security: 'Security & Access',
      lifecycle: 'Lifecycle Hooks',
      addVar: 'Add Variable',
      addVol: 'Add Volume',
      claimName: 'Claim Name',
      pathHost: 'Path on Host',
      mountPath: 'Mount Path',
      readOnly: 'Read Only',
      pullSecret: 'Image Pull Secrets',
      postStart: 'PostStart Command',
      preStop: 'PreStop Command',
      containerCommand: 'Command',
      containerArgs: 'Arguments',
      guaranteed: 'Guaranteed',
      max: 'Max',
      volType: 'Type',
      volName: 'Volume Name',
      resName: 'Resource Name',
      secName: 'Secret Name',
      tempStorage: 'Temporary storage for pod lifetime.',
      noteVolName: "Note: 'Volume Name' must match a volume defined in the section above.",
      alertEnvName: "Please enter an environment variable name.",
      alertVolName: "Please enter a volume name.",
      alertMount: "Please provide both a volume name and a mount path.",
      alertSecret: "Please enter a secret name.",
      healthChecks: 'Health Checks & Probes',
      livenessProbe: 'Liveness Probe',
      readinessProbe: 'Readiness Probe',
      probeType: 'Probe Type',
      initialDelay: 'Initial Delay (s)',
      period: 'Period (s)',
      timeout: 'Timeout (s)',
      failureThreshold: 'Failure Threshold',
      httpPath: 'HTTP Path',
      httpPort: 'HTTP Port',
      tcpPort: 'TCP Port',
      execCommand: 'Exec Command',
    },
    service: {
      networking: 'Networking',
      serviceType: 'Service Type',
      portConfig: 'Port Configuration',
      targetPort: 'Target Port',
      addPort: 'Add Port',
      portName: 'Port Name',
      externalIPs: 'External IPs',
      addIP: 'Add IP',
      ipPlaceholder: 'e.g. 192.168.1.100'
    },
    ingress: {
      annotations: 'Annotations',
      addAnnot: 'Add Annotation',
      controller: 'Controller Settings',
      className: 'Ingress Class Name',
      desc: 'Define which Ingress controller should implement the Ingress (e.g., nginx, alb, traefik).',
      rules: 'Rules & Paths',
      host: 'Host',
      path: 'Path',
      pathType: 'Type',
      serviceName: 'Service Name',
      servicePort: 'Service Port',
      addPath: 'Add Path',
      addRule: 'Add Host Rule',
    },
    configmap: {
      data: 'Data Configuration',
      filename: 'File Name / Key',
      content: 'Value / Content',
      addEntry: 'Add Data Entry',
    },
    pvc: {
      storage: 'Storage Configuration',
      request: 'Storage Request (Size)',
      className: 'Storage Class Name',
      volumeMode: 'Volume Mode',
      accessModes: 'Access Modes',
      note: 'Note: A volume can only be mounted using one access mode at a time, even if it supports many.',
      leaveEmpty: 'Leave empty to use the cluster\'s default StorageClass.'
    },
    validation: {
      title: 'K8s Spec Validation',
      passed: 'Validation Passed',
      errors: 'error(s)',
      warnings: 'warning(s)',
      // Best practice warnings
      missingLabels: 'Consider adding labels for better resource management',
      missingAppLabel: 'Consider adding "app" or "app.kubernetes.io/name" label',
      missingLimits: 'Container "{name}" has no resource limits set, may cause resource contention',
      missingRequests: 'Container "{name}" has no resource requests set, may affect scheduling',
      missingProbes: 'Container "{name}" has no health check probes configured',
      latestTag: 'Container "{name}" uses :latest or no image tag, use specific version recommended',
      singleReplica: 'Single replica deployment lacks high availability, recommend replicas >= 2 for production',
      loadBalancerCost: 'LoadBalancer type may incur cloud service costs',
      missingIngressClass: 'Consider specifying ingressClassName to clarify which Ingress controller to use',
      unknownKind: 'Unknown resource type: {kind}'
    },
    secret: {
      dataTitle: 'Data (Key-Value)',
      addData: 'Add Data',
      base64Hint: 'Values entered here are treated as plain text and will be automatically Base64 encoded in the generated YAML.',
      noData: 'No data entries. Click "Add Data" to start.'
    },
    job: {
      configuration: 'Job Configuration',
      completions: 'Completions',
      completionsHint: 'Number of successful completions',
      parallelism: 'Parallelism',
      parallelismHint: 'Max parallel pods',
      backoffLimit: 'Backoff Limit',
      backoffLimitHint: 'Retry limit before failure',
      restartPolicy: 'Restart Policy',
      restartPolicyHint: 'Never: Don\'t restart on failure | OnFailure: Restart on failure',
      container: 'Container',
      containerName: 'Container Name',
      commandJson: 'Command (JSON Array)',
      setExample: 'Set Example',
      clear: 'Clear'
    },
    cronjob: {
      schedule: 'Schedule',
      cronExpression: 'Cron Expression',
      cronHint: 'Example: "0 0 * * *" (Daily), "*/15 * * *" (Every 15 mins)',
      jobContainer: 'Job Container',
      commandJson: 'Command (JSON Array)',
      setDefault: 'Set Default',
      clear: 'Clear'
    },
    daemonset: {
      podSelector: 'Pod Selector',
      podSelectorHint: 'DaemonSet runs one pod on each node. Labels are used to identify pods.',
      appLabel: 'App Label',
      initContainers: 'Init Containers',
      addInitContainer: 'Add Init Container',
      containers: 'Containers',
      addContainer: 'Add Container',
      volumes: 'Volumes',
      volumeName: 'Volume Name',
      claimName: 'Claim Name',
      resourceName: 'Resource Name',
      hostPath: 'Host Path',
      addVolume: 'Add Volume',
      tempStorage: 'Temporary storage, deleted when pod is removed',
      noInitContainers: 'No init containers defined.'
    },
    statefulset: {
      configuration: 'StatefulSet Configuration',
      serviceName: 'Service Name',
      serviceNameHint: 'Headless service name for network identity',
      appLabel: 'App Label',
      initContainers: 'Init Containers',
      addInitContainer: 'Add Init Container',
      containers: 'Containers',
      addContainer: 'Add Container',
      volumes: 'Volumes',
      volumeName: 'Volume Name',
      claimName: 'Claim Name',
      resourceName: 'Resource Name',
      hostPath: 'Host Path',
      addVolume: 'Add Volume',
      tempStorage: 'Temporary storage, deleted when pod is removed',
      noInitContainers: 'No init containers defined.'
    },
    hpa: {
      scaleTarget: 'Scale Target',
      scaleTargetHint: 'Specify the resource to scale (Deployment, StatefulSet, etc.)',
      kind: 'Kind',
      resourceName: 'Resource Name',
      scalingConfig: 'Scaling Configuration',
      minReplicas: 'Min Replicas',
      minReplicasHint: 'Minimum number of replicas',
      maxReplicas: 'Max Replicas',
      maxReplicasHint: 'Maximum number of replicas',
      targetCPU: 'Target CPU Utilization (%)',
      targetCPUHint: 'Scale up when average CPU usage exceeds this percentage'
    }
  },
  zh: {
    common: {
      name: '名称',
      namespace: '命名空间',
      metadata: '元数据',
      add: '添加',
      cancel: '取消',
      generate: '生成',
      delete: '删除',
      type: '类型',
      key: '键',
      value: '值',
      port: '端口',
      protocol: '协议',
      selectOrType: '选择或输入...',
      requiredName: '请输入名称。',
      comment: '备注/注释',
      commentPlaceholder: '添加注释说明，将显示在 YAML 文件顶部...',
      commentHint: '注释内容将以 # 开头显示在生成的 YAML 文件顶部',
    },
    nav: {
      workloads: '工作负载',
      network: '网络',
      config: '配置与存储',
      deployment: 'Deployment',
      service: 'Service',
      ingress: 'Ingress',
      configmap: 'ConfigMap',
      secret: 'Secret',
      pvc: 'PVC',
      cronjob: 'CronJob',
      job: 'Job',
      daemonset: 'DaemonSet',
      statefulset: 'StatefulSet',
      hpa: 'HPA',
      apiKey: 'API Key',
      active: '有效',
      missing: '缺失',
      saved: '已保存的配置',
      noSaved: '暂无已保存配置',
    },
    header: {
      config: '配置',
      copy: '复制',
      copied: '已复制',
      export: '导出',
      preview: '预览',
      save: '保存',
      saveTitle: '保存当前配置',
      configName: '配置名称',
      saveBtn: '保存到本地',
    },
    deploy: {
      specs: '规格 (Specs)',
      replicas: '副本数 (Replicas)',
      containerConfig: '容器配置',
      containers: '容器列表',
      addContainer: '添加容器',
      initContainers: '初始化容器 (Init Containers)',
      addInitContainer: '添加初始化容器',
      containerName: '容器名称',
      image: '镜像',
      pullPolicy: '拉取策略',
      resources: '资源限制',
      requests: '请求 (Requests)',
      limits: '上限 (Limits)',
      cpu: 'CPU',
      memory: '内存',
      envVars: '环境变量',
      envFrom: '环境源 (批量导入)',
      envSourceType: '源类型',
      envValType: '值',
      envRefType: '引用',
      cmName: 'ConfigMap 名称',
      cmKey: '键 (Key)',
      volumes: '存储卷定义',
      mounts: '卷挂载',
      security: '安全与权限',
      lifecycle: '生命周期钩子',
      addVar: '添加变量',
      addVol: '添加存储卷',
      claimName: 'Claim 名称',
      pathHost: '主机路径',
      mountPath: '挂载路径',
      readOnly: '只读',
      pullSecret: '镜像拉取密钥',
      postStart: '启动后命令 (PostStart)',
      preStop: '停止前命令 (PreStop)',
      containerCommand: '命令 (Command)',
      containerArgs: '参数 (Args)',
      guaranteed: '保障资源',
      max: '最大资源',
      volType: '卷类型',
      volName: '卷名称',
      resName: '资源名称',
      secName: 'Secret 名称',
      tempStorage: 'Pod 生命周期内的临时存储。',
      noteVolName: "注意：'卷名称' 必须与上方定义的部分匹配。",
      alertEnvName: "请输入环境变量名称。",
      alertVolName: "请输入卷名称。",
      alertMount: "请提供卷名称和挂载路径。",
      alertSecret: "请输入密钥名称。",
      healthChecks: '健康检查 (Health Checks)',
      livenessProbe: '存活探针 (Liveness Probe)',
      readinessProbe: '就绪探针 (Readiness Probe)',
      probeType: '探针类型',
      initialDelay: '初始延迟 (秒)',
      period: '检测周期 (秒)',
      timeout: '超时时间 (秒)',
      failureThreshold: '失败阈值',
      httpPath: 'HTTP 路径',
      httpPort: 'HTTP 端口',
      tcpPort: 'TCP 端口',
      execCommand: '执行命令',
    },
    service: {
      networking: '网络配置',
      serviceType: '服务类型',
      portConfig: '端口配置',
      targetPort: '目标端口',
      addPort: '添加端口',
      portName: '端口名称',
      externalIPs: '外部 IP (External IPs)',
      addIP: '添加 IP',
      ipPlaceholder: '例如 192.168.1.100'
    },
    ingress: {
      annotations: '注解 (Annotations)',
      addAnnot: '添加注解',
      controller: '控制器设置',
      className: 'Ingress 类名',
      desc: '定义实现 Ingress 的控制器 (例如: nginx, alb, traefik)。',
      rules: '路由规则',
      host: '域名 (Host)',
      path: '路径',
      pathType: '路径类型',
      serviceName: '服务名称',
      servicePort: '服务端口',
      addPath: '添加路径',
      addRule: '添加规则',
    },
    configmap: {
      data: '数据配置',
      filename: '文件名 / 键',
      content: '值 / 内容',
      addEntry: '添加数据项',
    },
    pvc: {
      storage: '存储配置',
      request: '存储大小 (Request)',
      className: '存储类名 (StorageClass)',
      volumeMode: '卷模式',
      accessModes: '访问模式',
      note: '注意：一个卷一次只能使用一种访问模式挂载，即使它支持多种。',
      leaveEmpty: '留空以使用集群默认的 StorageClass。'
    },
    validation: {
      title: 'K8s 规范校验',
      passed: '校验通过',
      errors: '个错误',
      warnings: '个警告',
      // Best practice warnings
      missingLabels: '建议添加 labels 以便于资源管理和选择',
      missingAppLabel: '建议添加 "app" 或 "app.kubernetes.io/name" 标签',
      missingLimits: '容器 "{name}" 未设置资源上限 (limits)，可能导致资源争用',
      missingRequests: '容器 "{name}" 未设置资源请求 (requests)，可能影响调度',
      missingProbes: '容器 "{name}" 未配置健康检查探针',
      latestTag: '容器 "{name}" 使用了 :latest 或未指定镜像标签，建议使用具体版本',
      singleReplica: '单副本部署无法保证高可用，生产环境建议设置 replicas >= 2',
      loadBalancerCost: 'LoadBalancer 类型可能产生云服务费用',
      missingIngressClass: '建议指定 ingressClassName 以明确使用的 Ingress 控制器',
      unknownKind: '未知的资源类型: {kind}'
    },
    secret: {
      dataTitle: '数据 (键值对)',
      addData: '添加数据',
      base64Hint: '此处输入的值将被视为纯文本，并在生成的 YAML 中自动进行 Base64 编码。',
      noData: '暂无数据项。点击"添加数据"开始。'
    },
    job: {
      configuration: 'Job 配置',
      completions: '完成次数 (Completions)',
      completionsHint: '成功完成的次数',
      parallelism: '并行度 (Parallelism)',
      parallelismHint: '最大并行 Pod 数',
      backoffLimit: '重试限制 (Backoff Limit)',
      backoffLimitHint: '失败前的重试次数',
      restartPolicy: '重启策略 (Restart Policy)',
      restartPolicyHint: 'Never: 失败不重启 | OnFailure: 失败时重启',
      container: '容器',
      containerName: '容器名称',
      commandJson: '命令 (JSON 数组)',
      setExample: '设置示例',
      clear: '清除'
    },
    cronjob: {
      schedule: '调度配置',
      cronExpression: 'Cron 表达式',
      cronHint: '示例: "0 0 * * *" (每天), "*/15 * * *" (每 15 分钟)',
      jobContainer: 'Job 容器',
      commandJson: '命令 (JSON 数组)',
      setDefault: '设置默认值',
      clear: '清除'
    },
    daemonset: {
      podSelector: 'Pod 选择器',
      podSelectorHint: 'DaemonSet 在每个节点上运行一个 Pod。使用标签来识别 Pod。',
      appLabel: '应用标签',
      initContainers: '初始化容器 (Init Containers)',
      addInitContainer: '添加初始化容器',
      containers: '容器列表',
      addContainer: '添加容器',
      volumes: '存储卷',
      volumeName: '卷名称',
      claimName: 'Claim 名称',
      resourceName: '资源名称',
      hostPath: '主机路径',
      addVolume: '添加存储卷',
      tempStorage: '临时存储，Pod 删除时一并删除',
      noInitContainers: '未定义初始化容器。'
    },
    statefulset: {
      configuration: 'StatefulSet 配置',
      serviceName: '服务名称 (Service Name)',
      serviceNameHint: '用于网络标识的无头服务名称',
      appLabel: '应用标签',
      initContainers: '初始化容器 (Init Containers)',
      addInitContainer: '添加初始化容器',
      containers: '容器列表',
      addContainer: '添加容器',
      volumes: '存储卷',
      volumeName: '卷名称',
      claimName: 'Claim 名称',
      resourceName: '资源名称',
      hostPath: '主机路径',
      addVolume: '添加存储卷',
      tempStorage: '临时存储，Pod 删除时一并删除',
      noInitContainers: '未定义初始化容器。'
    },
    hpa: {
      scaleTarget: '扩缩目标',
      scaleTargetHint: '指定要扩缩的资源 (Deployment、StatefulSet 等)',
      kind: '资源类型 (Kind)',
      resourceName: '资源名称',
      scalingConfig: '扩缩配置',
      minReplicas: '最小副本数',
      minReplicasHint: '最小副本数量',
      maxReplicas: '最大副本数',
      maxReplicasHint: '最大副本数量',
      targetCPU: '目标 CPU 使用率 (%)',
      targetCPUHint: '当平均 CPU 使用率超过此百分比时进行扩容'
    }
  }
};

interface LanguageContextType {
  language: Language;
  setLanguage: (lang: Language) => void;
  t: typeof translations['en'];
}

const LanguageContext = createContext<LanguageContextType | undefined>(undefined);

export const LanguageProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [language, setLanguage] = useState<Language>('en');

  const value = {
    language,
    setLanguage,
    t: translations[language],
  };

  return (
    <LanguageContext.Provider value={value}>
      {children}
    </LanguageContext.Provider>
  );
};

export const useLanguage = () => {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
};
